[{"title":"Android Touch事件传递总结","date":"2016-05-19T12:45:37.000Z","path":"2016/05/19/android-view-touch/","text":"Android View的Touch事件传递主要涉及三个方法： boolean dispatchTouchEvent(MotionEvent ev) 负责事件的分发，返回值的确定很复杂，涉及是否绑定OnTouchListener、onTouch方法返回值、onTouchEvent返回值，对于ViewGroup与onInterceptTouchEvent返回值有关。 boolean onInterceptTouchEvent(MotionEvent ev) 是否拦截事件。只有ViewGroup有该方法，因为ViewGroup一般会包含子View，有时需要考虑对Touch事件的拦截。 boolean onTouchEvent(MotionEvent event) 消费Touch事件。返回值决定Touch事件是否向上传递给父ViewGroup。 看上面的描述肯定不懂，自己写个例子试验一下呗。 ViewGroupA和ViewGroupB继承自ViewGroup，作为两个自定义的View容器。红色部分的View直接继承自View类。在这三个自定义类中重写前面提到的相应方法，默认只打Log，同样给Activity的dispatchTouchEvent和onTouchEvent打Log，在不同情形下来看看输出。 一、默认情形 点击一下红色区域即ViewContent 默认都不拦截 默认都不消费 123456789101112D/MainActivity: MainActivity dispatchTouchEvent ACTION_DOWND/ViewGroupA: ViewGroupA dispatchTouchEvent ACTION_DOWND/ViewGroupA: ViewGroupA onInterceptTouchEvent ACTION_DOWND/ViewGroupB: ViewGroupB dispatchTouchEvent ACTION_DOWND/ViewGroupB: ViewGroupB onInterceptTouchEvent ACTION_DOWND/ViewContent: ViewContent dispatchTouchEvent ACTION_DOWND/ViewContent: ViewContent onTouchEvent ACTION_DOWND/ViewGroupB: ViewGroupB onTouchEvent ACTION_DOWND/ViewGroupA: ViewGroupA onTouchEvent ACTION_DOWND/MainActivity: MainActivity onTouchEvent ACTION_DOWND/MainActivity: MainActivity dispatchTouchEvent ACTION_UPD/MainActivity: MainActivity onTouchEvent ACTION_UP 调用顺序出来了，一个完整的Touch事件流由DOWN事件开始，经历0个或若干个MOVE事件（该例中未移动），最后UP事件结束。 事件的分发由上至下，事件到达某一层时先调用dispatchTouchEvent，由其决定将事件分发给哪个方法处理。 对于ViewGroup会传递给该层的onInterceptTouchEvent决定是否拦截，对于View则直接传递给onTouchEvent决定是否消费，该例中各层的onTouchEvent都返回默认false即都不消费事件，则事件会由子View的onTouchEvent向上传递至上层的onTouchEvent。 该例中的DOWN事件最终由MainActivity的onTouchEvent消费了，当后续的UP事件到来时，MainActivity的dispatchTouchEvent直接把UP事件交由其onTouchEvent处理。 示意图如下： 二、某一层消费事件（onTouchEvent返回true） 让ViewGroupB即蓝色区域接收到DOWN事件后，onTouchEvent返回true，即ViewGroupB消费了DOWN事件 onInterceptTouchEvent都不拦截事件 点击红色区域 1234567891011121314D/MainActivity: MainActivity dispatchTouchEvent ACTION_DOWND/ViewGroupA: ViewGroupA dispatchTouchEvent ACTION_DOWND/ViewGroupA: ViewGroupA onInterceptTouchEvent ACTION_DOWND/ViewGroupB: ViewGroupB dispatchTouchEvent ACTION_DOWND/ViewGroupB: ViewGroupB onInterceptTouchEvent ACTION_DOWND/ViewContent: ViewContent dispatchTouchEvent ACTION_DOWND/ViewContent: ViewContent onTouchEvent ACTION_DOWND/ViewGroupB: ViewGroupB onTouchEvent ACTION_DOWND/MainActivity: MainActivity dispatchTouchEvent ACTION_UPD/ViewGroupA: ViewGroupA dispatchTouchEvent ACTION_UPD/ViewGroupA: ViewGroupA onInterceptTouchEvent ACTION_UPD/ViewGroupB: ViewGroupB dispatchTouchEvent ACTION_UPD/ViewGroupB: ViewGroupB onTouchEvent ACTION_UPD/MainActivity: MainActivity onTouchEvent ACTION_UP 可以看出，DOWN事件从上至下分发，最下层的ViewContent没有消费，向上传递时被ViewGroupB消费了，后续的UP事件会分发到ViewGroupB时直接交给它的onTouchEvent处理。 因为DOWN事件被ViewGroupB消费了，后续事件也不用考虑拦截了（后续分发事件到ViewGroupB层时，ViewGroupB的onInterceptTouchEvent没有调用），dispatchTouchEvent后直接给ViewGroupB的onTouchEvent处理。 示意图： 三、某一层拦截事件（onInterceptTouchEvent返回true）1. 接收到DOWN事件就拦截 ViewGroupB的onInterceptTouchEvent在收到DOWN事件时返回true 都不消费事件，即onTouchEvent默认返回。 点击红色区域 12345678910D/MainActivity: MainActivity dispatchTouchEvent ACTION_DOWND/ViewGroupA: ViewGroupA dispatchTouchEvent ACTION_DOWND/ViewGroupA: ViewGroupA onInterceptTouchEvent ACTION_DOWND/ViewGroupB: ViewGroupB dispatchTouchEvent ACTION_DOWND/ViewGroupB: ViewGroupB onInterceptTouchEvent ACTION_DOWND/ViewGroupB: ViewGroupB onTouchEvent ACTION_DOWND/ViewGroupA: ViewGroupA onTouchEvent ACTION_DOWND/MainActivity: MainActivity onTouchEvent ACTION_DOWND/MainActivity: MainActivity dispatchTouchEvent ACTION_UPD/MainActivity: MainActivity onTouchEvent ACTION_UP 可以看到，ViewGroupB的onInterceptTouchEvent在收到DOWN事件时返回true，即拦截了DOWN事件，那么该事件直接交给它的onTouchEvent处理了，事件没有下发到下层，若不消费事件则继续向上找消费者。 2. DOWN事件不拦截，后续事件拦截我们让ViewGroupB接受DOWN事件时不拦截，即下层会收到DOWN事件，让最底层View消费DOWN，在MOVE事件到来时ViewGroupB拦截，会发生什么呢？ ViewGroupB接受DOWN事件时不拦截 红色区域的ViewContent收到DOWN的onTouchEvent返回true，即消费事件 ViewGroupB接受MOVE事件时onInterceptTouchEvent返回true，即拦截MOVE事件 点击红色区域 123456789101112131415161718192021222324252627D/MainActivity: MainActivity dispatchTouchEvent ACTION_DOWND/ViewGroupA: ViewGroupA dispatchTouchEvent ACTION_DOWND/ViewGroupA: ViewGroupA onInterceptTouchEvent ACTION_DOWND/ViewGroupB: ViewGroupB dispatchTouchEvent ACTION_DOWND/ViewGroupB: ViewGroupB onInterceptTouchEvent ACTION_DOWND/ViewContent: ViewContent dispatchTouchEvent ACTION_DOWND/ViewContent: ViewContent onTouchEvent ACTION_DOWND/MainActivity: MainActivity dispatchTouchEvent ACTION_MOVED/ViewGroupA: ViewGroupA dispatchTouchEvent ACTION_MOVED/ViewGroupA: ViewGroupA onInterceptTouchEvent ACTION_MOVED/ViewGroupB: ViewGroupB dispatchTouchEvent ACTION_MOVED/ViewGroupB: ViewGroupB onInterceptTouchEvent ACTION_MOVED/ViewContent: ViewContent dispatchTouchEvent ACTION_CANCELD/ViewContent: ViewContent onTouchEvent ACTION_CANCELD/MainActivity: MainActivity onTouchEvent ACTION_MOVED/MainActivity: MainActivity dispatchTouchEvent ACTION_MOVED/ViewGroupA: ViewGroupA dispatchTouchEvent ACTION_MOVED/ViewGroupA: ViewGroupA onInterceptTouchEvent ACTION_MOVED/ViewGroupB: ViewGroupB dispatchTouchEvent ACTION_MOVED/ViewGroupB: ViewGroupB onTouchEvent ACTION_MOVED/MainActivity: MainActivity onTouchEvent ACTION_MOVED/MainActivity: MainActivity dispatchTouchEvent ACTION_UPD/ViewGroupA: ViewGroupA dispatchTouchEvent ACTION_UPD/ViewGroupA: ViewGroupA onInterceptTouchEvent ACTION_UPD/ViewGroupB: ViewGroupB dispatchTouchEvent ACTION_UPD/ViewGroupB: ViewGroupB onTouchEvent ACTION_UPD/MainActivity: MainActivity onTouchEvent ACTION_UP 看到了吗，DOWN事件没什么问题，从各层分发直至找到它的消费者——ViewContent。但是，当后续的MOVE产生时，在分发过程中被ViewGroupB拦截，这时本来的消费者即下一层的ViewContent会收到CANCEL事件。 当MOVE再次产生时，直接分发到ViewGroupB层就停止了，会交给ViewGroupB的onTouchEvent处理MOVE，在不消费MOVE的情况下，MOVE事件都不会向上传递给ViewGroupA的onTouchEvent。 3. 子View请求父ViewGroup不拦截事件在2的基础上，DOWN被最底层消费，而MOVE和后续事件被上层拦截了。如果在这种情形下，下层还想收到后续事件怎么办呢？可以调用： 1getParent().requestDisallowInterceptTouchEvent(true); 这句代码的作用是下层View请求父ViewGroup不拦截事件，在2的例子中最底层View消费DOWN后，调用这句，就可以继续收到后续事件了。 12345678910111213D/MainActivity: MainActivity dispatchTouchEvent ACTION_DOWND/ViewGroupA: ViewGroupA dispatchTouchEvent ACTION_DOWND/ViewGroupA: ViewGroupA onInterceptTouchEvent ACTION_DOWND/ViewGroupB: ViewGroupB dispatchTouchEvent ACTION_DOWND/ViewGroupB: ViewGroupB onInterceptTouchEvent ACTION_DOWND/ViewContent: ViewContent dispatchTouchEvent ACTION_DOWND/ViewContent: ViewContent onTouchEvent ACTION_DOWND/MainActivity: MainActivity dispatchTouchEvent ACTION_MOVED/ViewGroupA: ViewGroupA dispatchTouchEvent ACTION_MOVED/ViewGroupB: ViewGroupB dispatchTouchEvent ACTION_MOVED/ViewContent: ViewContent dispatchTouchEvent ACTION_MOVED/ViewContent: ViewContent onTouchEvent ACTION_MOVED/MainActivity: MainActivity onTouchEvent ACTION_MOVE 注意1：在调用requestDisallowInterceptTouchEvent方法后，后续事件被分发时，各层都不走onInterceptTouchEvent方法。 注意2: 当某一层的View在调用了setOnClickListener或setOnTouchListener后，情况和注意1一样，后续事件被分发时，各层都不走onInterceptTouchEvent方法。 注意3: 某一层在onTouchEvent消费DOWN事件，显示返回true后，后续事件会尝试继续找它，对于无显示返回true的后续事件，最终还会传递到MainActivity的onTouchEvent。 参考资料关于Android Touch事件传递的文章和讲解网上很多，其实有下面两个＋写Demo实验就够了。 一个Dave Smith的讲解视频：Mastering the Android Touch System 上面视频的课件：Mastering the Android Touch System.pdf","tags":[{"name":"Android","slug":"Android","permalink":"http://kodyan.github.io/tags/Android/"}]},{"title":"Hello World","date":"2016-05-04T16:05:28.000Z","path":"2016/05/05/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"Java Annotation Tutorials","date":"2016-04-28T12:45:37.000Z","path":"2016/04/28/java-annotation/","text":"注：本文主要翻译自Lesson: Annotations，学习一下Java注解。 Annotations（注解）是一种元数据（metadata），用于描述一段程序但对程序的运行不产生直接影响。 注解有一些作用，其中包括： 为编译器提供信息——注解可以被编译器用于探测 errors 或者 suppress warnings。 编译时或部署时处理——软件处理注解后可生成代码，XML 文件等。 运行时处理——一些注解可以用于运行时检查。 Annotations基础注解的格式注解最简单的格式如下： 1@Entity @字符告知编译器接下来是一个注解，下面这个例子是一个名为Override的注解： 12@Overridevoid mySuperMethod() &#123; ... &#125; 注解还可以包含一些带命名或不带命名的元素，每个元素会有相应的 value： 12345@Author( name = \"Benjamin Franklin\", date = \"3/27/2003\")class MyClass() &#123; ... &#125; 或 12@SuppressWarnings(value = \"unchecked\")void myMethod() &#123; ... &#125; 如果只包含一个带命名的 value，那么这个 value 的 name 可以忽略： 12@SuppressWarnings(\"unchecked\")void myMethod() &#123; ... &#125; 如果注解里没有元素，那么括号可以被省略，参考前面的@Override示例。 对于同一个声明，可以用多个注解： 123@Author(name = \"Jane Doe\")@EBookclass MyClass &#123; ... &#125; 如果注解的类型相同，这种情况被称为重复注解（repeating annotation）： 123@Author(name = \"Jane Doe\")@Author(name = \"John Smith\")class MyClass &#123; ... &#125; 重复注解自 Java 8 开始支持，详见 Repeating Annotations 部分。 注解的类型可以是java.lang或java.lang.annotation包下面定义的类型，比如前面例子中的Override和SuppressWarnings就是 Java 预置的注解类型。此外还可以自定义注解类型，如前面例子中的Author和Ebook。 注解可以用在什么地方注解可以用于声明类、域、方法和其他程序的元素，当用于声明时，注解往往自成一行。 从 Java 8 开始，注解还可作为类型（type），如下： 创建类的实例： 1new @Interned MyObject(); 转型： 1myString = (@NonNull String) str; 实现接口： 12class UnmodifiableList&lt;T&gt; implements @Readonly List&lt;@Readonly T&gt; &#123; ... &#125; 抛异常的声明： 12void monitorTemperature() throws @Critical TemperatureException &#123; ... &#125; 这种形式的注解被称为类型注解（type annotation）。 声明一个注解类型在代码中很多注解代替了注释（comments）。 比如，一个开发团队通常在一个类的 body 起始的位置添加一些重要的注释： 123456789101112public class Generation3List extends Generation2List &#123; // Author: John Doe // Date: 3/17/2002 // Current revision: 6 // Last modified: 4/12/2004 // By: Jane Doe // Reviewers: Alice, Bill, Cindy // class code goes here&#125; 如果使用注解的话，首先要定义一个注解类型，语法如下： 123456789@interface ClassPreamble &#123; String author(); String date(); int currentRevision() default 1; String lastModified() default \"N/A\"; String lastModifiedBy() default \"N/A\"; // Note use of array String[] reviewers();&#125; 注解的定义和接口的定义有些像，interface前面多了个@。 上面这个注解的定义中包括了注解类型和元素声明，其中 default 值是可选的。 定义好注解之后，我们可以像下面这样使用它： 1234567891011121314@ClassPreamble ( author = \"John Doe\", date = \"3/17/2002\", currentRevision = 6, lastModified = \"4/12/2004\", lastModifiedBy = \"Jane Doe\", // Note array notation reviewers = &#123;\"Alice\", \"Bob\", \"Cindy\"&#125;)public class Generation3List extends Generation2List &#123;// class code goes here&#125; Note：为了让 Java Doc 包含注解@ClassPreamble的信息，我们需要在定义@ClassPreamble时为它再加上注解@Documented： 12345678910&gt;// import this to use @Documented&gt;import java.lang.annotation.*;&gt;@Documented&gt;@interface ClassPreamble &#123;&gt; // Annotation element definitions &gt;&#125;&gt; 预置的注解类型Java API 中预定义了一些注解类型，一些用于编译器，还有一些用于其它注解。 Java使用的注解类型java.lang中预置的注解有：@Deprecated, @Override, 和 @SuppressWarnings。 @Deprecated\u0001注解表示被标记的元素是deprecated的，不建议再使用的元素。当程序使用了被@Deprecated注解的方法、类或域时，编译器会生成一个warning信息。当一个元素是deprecated，在Javadoc中也要使用@deprecated标记，Doc中的d小写，注解中是大写的D： 12345678 // Javadoc comment follows /** * @deprecated * explanation of why it was deprecated */ @Deprecated static void deprecatedMethod() &#123; &#125;&#125; @Override注解告诉编译器，该方法是重写自父类的方法： 1234// mark method as a superclass method // that has been overridden @Override int overriddenMethod() &#123; &#125; 用@Override的好处是如果这个方法没用正确重写父类的方法时，编译器会产生一个 error 提示。 @SuppressWarnings注解提示编译器不用产生指定的 warning 信息，如调用一个 deprecated 方法时，编译器会生成一个 waring 提示，使用@SuppressWarnings注解后，这个 waring 就被抑制了： 12345678// use a deprecated method and tell // compiler not to generate a warning @SuppressWarnings(\"deprecation\") void useDeprecatedMethod() &#123; // deprecation warning // - suppressed objectOne.deprecatedMethod(); &#125; @SafeVarargs用于方法或构造器时，断言可变参数不会产生潜在的危险，由可变参数使用而产生的 warning 会被 suppressed。 @FunctionalInterface是Java 8引入的，表示函数式接口。 注解的注解用于其它注解的注解，被称为元注解（meta-annotations），下面设计java.lang.annotation包里的相关注解。 @Retention指定了注解的保留方式： RetentionPolicy.SOURCE – 被标记的注解只保留在源码级别，会被编译器忽略。 RetentionPolicy.CLASS – 被标记的注解保留至编译时，会被JVM忽略。 RetentionPolicy.RUNTIME – 被标记的注解被JVM保留，会用于运行时环境。 @Documented注解信息会被 Javadoc 工具写入文档。 @Target起限制作用，表示注解用于描述哪种 Java 元素： ElementType.ANNOTATION_TYPE 用于描述注解 ElementType.CONSTRUCTOR 用于描述构造器 ElementType.FIELD 用于描述域 ElementType.LOCAL_VARIABLE 用于描述局部变量 ElementType.METHOD 用于描述方法的注解 ElementType.PACKAGE 用于描述包 ElementType.PARAMETER 用于描述参数 ElementType.TYPE 用于描述一个类的任何元素 @Inherited表示该注解是可以被继承的，只能用于声明类。 @Repeatable在Java 8引入，表示被标记的注解可以被重复用于同一个声明。 扩展阅读： Type Annotations and Pluggable Type Systems Repeating Annotations Java中的注解是如何工作的？","tags":[{"name":"Java","slug":"Java","permalink":"http://kodyan.github.io/tags/Java/"}]},{"title":"Android支持的图片格式","date":"2016-04-28T03:45:37.000Z","path":"2016/04/28/android-support-image/","text":"Android官方文档中Supported Media Formats部分介绍了Android支持的多媒体格式，Android支持的图片格式如下图。 本文对这几种图片格式做个学习总结。 JPEGJPEG（发音为jay-peg, IPA：[ˈdʒeɪpɛg]）是一种针对照片视频而广泛使用的一种压缩标准方法。这个名称代表Joint Photographic Experts Group（联合图像专家小组）。 常用的.jpg文件是有损压缩 不支持背景透明 适用于照片等色彩丰富的大图压缩 不适用于logo，线图 GIFGIF，图像互换格式（GIF，Graphics Interchange Format）是一种位图图形文件格式，以8位色（即256种颜色）重现真彩色的图像。它采用无损压缩技术，只要图像不多于256色，则可既减少文件的大小，又保持成像的质量。 优秀的压缩算法使其在一定程度上保证图像质量的同时将体积变得很小。 可插入多帧，从而实现动画效果。 可设置透明色。 由于采用了8位压缩，最多只能处理256种颜色，故不宜应用于真彩色图片。 PNGPNG，便携式网络图形（Portable Network Graphics，PNG）是一种无损压缩的位图图形格式，支持索引、灰度、RGB三种颜色方案以及Alpha通道等特性。 支持256色调色板技术以产生小体积文件 最高支持48位真彩色图像以及16位灰度图像。 支持Alpha通道的透明/半透明特性。 支持图像亮度的Gamma校准信息。 支持存储附加文本信息，以保留图像名称、作者、版权、创作时间、注释等信息。 使用无损压缩。 渐近显示和流式读写，适合在网络传输中快速显示预览效果后再展示全貌。 使用CRC防止文件出错。 最新的PNG标准允许在一个文件内存储多幅图像。 Android开发中的切图素材多为.png格式。 BPMBMP（全称Bitmap）是Windows操作系统中的标准图像文件格式，可以分成两类：设备相关位图（DDB）和设备无关位图（DIB），使用非常广。它采用位映射存储格式，除了图像深度可选以外，不采用其他任何压缩，因此，BMP文件所占用的空间很大。 BMP文件的图像深度可选lbit、4bit、8bit及24bit。BMP文件存储数据时，图像的扫描方式是按从左到右、从下到上的顺序。 WebPWebP（发音weppy），是一种同时提供了有损压缩与无损压缩的图片文件格式，派生自视频编码格式VP8，是由Google在购买On2 Technologies后发展出来，以BSD授权条款发布。 从官网介绍来看，无损的WebP图片比PNG小26%，有损的WebP图片比JPEG小25-34%，同时，无损WebP支持透明及alpha通道，有损在一定条件下同样支持。 WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。 相较编码JPEG文件，编码同样质量的WebP文件也需要占用更多的计算资源。 Android 4.0+默认支持WebP，Android 4.2.1+开始支持无损WebP和带alpha通道的WebP。 参考资料： A new image format for the Web WebP 探寻之路 PNG vs. GIF vs. JPEG vs. SVG - When best to use?","tags":[{"name":"Android","slug":"Android","permalink":"http://kodyan.github.io/tags/Android/"}]},{"title":"不如自己读一遍AsyncTask源码","date":"2016-04-28T03:45:37.000Z","path":"2016/04/28/AsyncTask/","text":"看多少总结都不如自己试着分析一遍，RTFSC。 AsyncTask用法直接上官网的例子: 123456789101112131415161718192021222324private class DownloadFilesTask extends AsyncTask&lt;URL, Integer, Long&gt; &#123; // Do the long-running work in here protected Long doInBackground(URL... urls) &#123; int count = urls.length; long totalSize = 0; for (int i = 0; i &lt; count; i++) &#123; totalSize += Downloader.downloadFile(urls[i]); publishProgress((int) ((i / (float) count) * 100)); // Escape early if cancel() is called if (isCancelled()) break; &#125; return totalSize; &#125; // This is called each time you call publishProgress() protected void onProgressUpdate(Integer... progress) &#123; setProgressPercent(progress[0]); &#125; // This is called when doInBackground() is finished protected void onPostExecute(Long result) &#123; showNotification(\"Downloaded \" + result + \" bytes\"); &#125;&#125; 写一个类继承AsyncTask，重写三个方法： doInBackground：在这里面执行耗时的异步任务 onProgressUpdate：更新进度在这个方法里写 onPostExecute：任务执行后的操作放这里面 此外还有两个方法可以重写： onPreExecute onCancelled AsyncTask类指定三个泛型参数，这三个参数的用途如下： Params——在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。 Progress——后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。 Result——当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。 启动这个任务：1new DownloadFilesTask().execute(url1, url2, url3); 源码分析我的SDK版本时API 23，各版本的AsyncTask的具体代码可能会有出入，但基本的原理是一样的。 先看看构造器里都做了什么： 1234567891011121314151617181920212223242526272829303132/** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. */ public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(\"An error occurred while executing doInBackground()\", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; &#125; 首先用匿名内部类的形式new了一个WorkerRunnable\\实例，WorkerRunnable是实现了Callable接口的一个抽象类，Callable代码如下，包含一个带反回类型的call()方法： 123456789public interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; 回构造器看看匿名内部类里是如何实现call()方法的，在call()方法中将线程的优先级设置为了THREAD_PRIORITY_BACKGROUND，官网说了： If you don’t set the thread to a lower priority this way, then the thread could still slow down your app because it operates at the same priority as the UI thread by default. 意思是如果不降低线程的优先级，那么子线程默认和UI线程优先级一样，执行起来app可能就卡了。 接下来就调用了doInBackground方法，返回一个result，这都是在子线程里的操作，那怎么把result传递给主线程呢？追进postResult看看： 1234567private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; &#125; 熟悉的Message出现了，还调用了sendToTarget()方法，这不就是通过Hadler传递的方式吗。再看getHandler方法返回的是静态内部类InternalHandler的实例，InternalHandler继承自Handler： 1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;\"unchecked\", \"RawUseOfParameterizedType\"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125; &#125; InternalHandler构造器中拿的是主线程的looper，handleMessage是接收到不同消息进行相应的处理，finish： 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 接收到finish消息后，如果调用了isCancelled就回调onCancelled方法，否则回调onPostExecute方法。如果消息的更新progress那么就回调onProgressUpdate方法。这样就把result传递给了主线程。 再回到构造器接着往下看： 123456789101112131415mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(\"An error occurred while executing doInBackground()\", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; 同样用匿名内部类生成一个FutureTask\\实例，FutureTask实现了RunnableFuture接口，RunnableFuture的源码如下，它同时继承了Runnable接口和Future接口，既可以作为Runnable的引用也可以作为Future的引用，Future接口中定义cancel方法和get方法用于取出线程的执行结果。 1234567public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run();&#125; 前面的FutureTask匿名内部类重写了done方法，调用postResultIfNotInvoked，如果之前WorkerRunnable的call方法抛异常了，则再次把result传递出去。 好了，构造器里定义好了一个实现Callable接口的WorkerRunnable实例和一个实现了Runnable接口和Future接口的FutureTask实例。 接下来看看调用execute方法后都做了什么： 1234@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params); &#125; 再追进executeOnExecutor方法： 123456789101112131415161718192021222324@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(\"Cannot execute task:\" + \" the task is already running.\"); case FINISHED: throw new IllegalStateException(\"Cannot execute task:\" + \" the task has already been executed \" + \"(a task can be executed only once)\"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; 首先回调onPreExecute()方法，这还是在主线程，接下来调用传递进来的Executor实例的execute方法开始执行任务：1exec.execute(mFuture); 传进来的sDefaultExecutor是定义的静态内部类SerialExecutor的实例，去源码看到它实现的execute方法中使用一个双端队列来串行执行传进来的Runnable引用的run方法，具体引用是谁呢？看上面，是mFuture。在mFuture的run方法中会调用Callable引用的call方法，具体引用是谁呢？回AsyncTask构造器看，是mWorker。真正执行任务的是线程池THREAD_POOL_EXECUTOR。 AsyncTask默认线程池参数把THREAD_POOL_EXECUTOR具体参数和定义也贴上： 1234567891011121314151617181920212223242526 private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors(); private static final int CORE_POOL_SIZE = CPU_COUNT + 1; private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1; private static final int KEEP_ALIVE = 1; private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, \"AsyncTask #\" + mCount.getAndIncrement()); &#125; &#125;; private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128); /** * An &#123;@link Executor&#125; that can be used to execute tasks in parallel. */ public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); 可以看到线程池的核心线程数是（CPU数＋1），最大容量是（2*CPU数＋1），阻塞队列容量128。记得AsyncTask中的线程池核心线程数是5啊，对吗？什么时候改的呢，这是API 23即Android 6.0，我们去历史版本看看吧，我一般在androidxref.com看各个版本的源码。 搜索之后可以得知，在Android 4.3的源码中AsyncTask的配置还是如下所示： 12345678private static final int CORE_POOL_SIZE = 5; private static final int MAXIMUM_POOL_SIZE = 128; private static final int KEEP_ALIVE = 1; private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(10); 核心线程数5，线程池最大容量128，阻塞队列容量10。从Android 4.4开始就变成上面看到的根据CPU数的配置了，涨了一点点知识，不能再说AsyncTask默认线程池核心线程数是5啦。 此外，我们还可以通过setDefaultExecutor来使用自定义的Executor和线程池来执行任务。 以上分析下来确实学到了不少啊。","tags":[{"name":"Android","slug":"Android","permalink":"http://kodyan.github.io/tags/Android/"}]},{"title":"Android中的LruCache","date":"2016-04-21T12:45:37.000Z","path":"2016/04/21/LruCache/","text":"LRU是Least Recently Used的缩写，即“最近最少使用”，说明LRU缓存算法的淘汰策略是把最近最少使用的数据移除，让出内存给最新读取的数据。下面看一下Android中的LruCache。 android.util.LruCache这个LruCache在android.util包下，是API level 12引入的，对于API level 12之前的系统可以使用support library中的LruCache。先来看看android.util.LruCache的源码。 首先是成员变量： 1234567891011private final LinkedHashMap&lt;K, V&gt; map; /** Size of this cache in units. Not necessarily the number of elements. */ private int size; private int maxSize; private int putCount; private int createCount; private int evictionCount; private int hitCount; private int missCount; LruCache内部使用一个LinkedHashMap作为存储容器，并对各种操作进行计次。 构造器： 1234567public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException(\"maxSize &lt;= 0\"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); &#125; 构造器的参数maxSize用于指定缓存的最大容量，并初始化一个LinkedHashMap，顺便看看这个LinkedHashMap的构造函数： 12345public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); init(); this.accessOrder = accessOrder; &#125; initialCapacity即初始容量设为0，装填因子loadFactor设为0.75，accessOrder设为true，即链表中的元素按照最近最少访问到最多访问排序。这里设置的装填因子为0.75，设置其它值行不行呢？在LinkedHashMap这个构造器中只是将loadFactor作为参数传给了父类构造器，该父类构造器如下： 12345678910111213public HashMap(int capacity, float loadFactor) &#123; this(capacity); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) &#123; throw new IllegalArgumentException(\"Load factor: \" + loadFactor); &#125; /* * Note that this implementation ignores loadFactor; it always uses * a load factor of 3/4. This simplifies the code and generally * improves performance. */ &#125; 调用了HashMap的构造器，可以看到只是对loadFactor进行了合法检查，除此之外没有其他调用或赋值操作，Note中解释了，这个loadFactor没用，装填因子永远使用3/4，也就是0.75。所以在构造LinkedHashMap时，设了装填因子也没什么用。 继续看LruCache，resize方法更新链表容量，调用trimToSize方法。 12345678910public void resize(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException(\"maxSize &lt;= 0\"); &#125; synchronized (this) &#123; this.maxSize = maxSize; &#125; trimToSize(maxSize); &#125; 先看get方法，key为空会抛异常，取出对应的value，若不为空则命中次数hitCount加1并return这个value，否则missCount加1。该value为空时继续向下执行，根据key尝试创建value，如果创建返回的createdValue是null，那就确实没有该值，若创建操作返回的createdValue不为null，则尝试把createdValue放回map，若存在旧值则返回旧值，否则返回这个createdValue。 12345678910111213141516171819202122232425262728293031323334353637383940public final V get(K key) &#123; if (key == null) &#123; throw new NullPointerException(\"key == null\"); &#125; V mapValue; synchronized (this) &#123; mapValue = map.get(key); if (mapValue != null) &#123; hitCount++; return mapValue; &#125; missCount++; &#125; V createdValue = create(key); if (createdValue == null) &#123; return null; &#125; synchronized (this) &#123; createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) &#123; // There was a conflict so undo that last put map.put(key, mapValue); &#125; else &#123; size += safeSizeOf(key, createdValue); &#125; &#125; if (mapValue != null) &#123; entryRemoved(false, key, createdValue, mapValue); return mapValue; &#125; else &#123; trimToSize(maxSize); return createdValue; &#125; &#125; put方法将键值对放入map，重新计算大小之后调用trimToSize方法，删除访问次数最少的元素。 12345678910111213141516171819202122public final V put(K key, V value) &#123; if (key == null || value == null) &#123; throw new NullPointerException(\"key == null || value == null\"); &#125; V previous; synchronized (this) &#123; putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; if (previous != null) &#123; entryRemoved(false, key, previous, value); &#125; trimToSize(maxSize); return previous; &#125; trimToSize方法中会一直尝试删除队首元素即访问次数最少的元素，直到size不超过最大容量。 1234567891011121314151617181920212223242526272829public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + \".sizeOf() is reporting inconsistent results!\"); &#125; if (size &lt;= maxSize) &#123; break; &#125; Map.Entry&lt;K, V&gt; toEvict = map.eldest(); if (toEvict == null) &#123; break; &#125; key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125; &#125; android.support.v4.util.LruCachesupport v4包中的LruCache可以用于API level 12之前的系统，和android.util包的LruCache的区别是在trimToSize中获取将要删除元素的方法不一样： android.util.LruCache 1Map.Entry&lt;K, V&gt; toEvict = map.eldest(); android.support.v4.util.LruCache 1Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); LinkedHashMap的eldest()方法已经被标注为@hide，所以使用android.support.v4.util.LruCache更加保险一点。","tags":[{"name":"Android","slug":"Android","permalink":"http://kodyan.github.io/tags/Android/"}]},{"title":"Linux命令笔记","date":"2015-09-07T09:02:16.000Z","path":"2015/09/07/Linux-command/","text":"打印文件的第n行sed -n -e &apos;np&apos; filename 对含有形如key,value的数据按value排序将排序结果写回原文件： sort -t &quot;,&quot; -n -r -k2 filename -o filename 统计当前目录下Java文件行数find . -name &quot;*.java&quot; |xargs cat|grep -v ^$|wc -l 打印内容中包含某字符串的文件名例如打印包含bitmap size exceeds VM budget的文件的文件名 find .|xargs grep -ri &quot;bitmap size exceeds VM budget&quot; -l 提取逗号分隔的某一列例如file的内容如下： a,2b,1c,3d,4 提取出第一列： abcd 则执行： cut -d&apos;,&apos; -f1 file 按每行字符串长度排序cat file | while read i;do echo ${#i},$i;done | sort -nr|cut -f2 -d&apos;,&apos;","tags":[{"name":"Linux","slug":"Linux","permalink":"http://kodyan.github.io/tags/Linux/"}]},{"title":"Android开发工具与资料汇总","date":"2015-04-11T12:45:37.000Z","path":"2015/04/11/android-develop-tools&resources/","text":"平时集了一些别人分享的不错的Android开发工具和资源，我会持续把收录的东西放到这篇博客中。 一款强大的模拟器 Genymotion Gradle http://rinvay.github.io/ 图标 Google官方开源的海量Material Design风格的图标：Material Design icons by Google 在线可视化调色板：Android Material Design可视化调色板 一个在线Material Design配色工具：Material Design在线配色工具 官方Material Design调色数值：Material Design调色板参考值 各种dpi换算：android dpi计算器 在线生成各种图标，包括Launcher icons、Action bar and tab icons、Notification icons、Generic icons以及Nine-Patch：Android Asset Studio 布局 控件命名及各种比例确定：Android Cheatsheet for Graphic Designers Github开源项目 Trinea总结的Github开源项目：https://github.com/Trinea/android-open-project UI开源项目汇总：https://github.com/wasabeef/awesome-android-ui 控件和动画效果收录：23CODE 一个Android开源库分享站点：Moo Droid 一个分享开源库的Google Plus社区：Android projects on Github Android开发性能优化 Android性能优化典范 Facebook工程师是如何改进他们Android客户端的 Android布局优化 http://android-developers.blogspot.jp/2009/02/android-layout-tricks-1.html http://www.curious-creature.com/2009/02/25/android-layout-trick-2-include-to-reuse/comment-page-1/ http://android-developers.blogspot.jp/2009/03/android-layout-tricks-3-optimize-by.html http://android-developers.blogspot.jp/2009/03/android-layout-tricks-3-optimize-with.html 设计模式 Android源码设计模式分析项目 设计模式Java实现 源码 在线查看Android源码：AndroidXRef 算法 《程序员编程艺术：面试和算法心得》：https://github.com/julycoding/The-Art-Of-Programming-By-July 常见算法Java实现：https://github.com/pedrovgs/Algorithms Blog Trinea：http://www.trinea.cn/ 胡凯：http://hukai.me/ stormzhang： http://stormzhang.com/ 脉脉不得语的技术博客：http://www.inferjay.com/ Lucida：http://lucida.me/ Sam：http://blog.isming.me/ Android Performance：http://androidperformance.com/ codeKK：http://www.codekk.com/ Android Tech Frontier：https://github.com/bboyfeiyu/android-tech-frontier jcodecraeer：http://jcodecraeer.com/plus/list.php?tid=16","tags":[{"name":"Android","slug":"Android","permalink":"http://kodyan.github.io/tags/Android/"}]},{"title":"Toast及时更新显示文字及控制提示消失","date":"2015-03-16T12:28:38.000Z","path":"2015/03/16/toast-refresh&cancel/","text":"在测试Toast时频繁让Toast显示文字会有延迟，因为Toast的消息队列中要按指定的duration显示完当前内容后才会显示下一条消息。如何才能让Toast及时更新显示内容呢？ 有些应用双击Back退出时，会有一个“再次点击返回退出”的提示，当连续两次快速点击Back退出应用时，“再次点击返回退出”提示依然还在，指导显示完指定的duration。你都退出了，而你产生的Toast还在，这样合理吗？ 本文内容 及时更新Toast显示的内容 控制Toast消失 我自己写了一个Toast的工具类，实现了及时更新Toast显示的内容，以及控制Toast消失。下面是参考代码：123456789101112131415161718192021222324252627package com.bupt.booktrade.utils;import android.content.Context;import android.widget.Toast;public class ToastUtils&#123; private static Toast mToast; public static void showToast(Context context, int msg, int duration) &#123; if (mToast == null) &#123; mToast = Toast.makeText(context, msg, duration); &#125; else &#123; mToast.setText(msg); &#125; mToast.show(); &#125; public static void showToast(Context context, String msg, int duration) &#123; if (mToast == null) &#123; mToast = Toast.makeText(context, msg, duration); &#125; else &#123; mToast.setText(msg); &#125; mToast.show(); &#125; public static void clearToast()&#123; mToast.cancel(); &#125;&#125; 通过ToastUtils直接调用这三个静态方法即可。","tags":[{"name":"Android","slug":"Android","permalink":"http://kodyan.github.io/tags/Android/"}]},{"title":"Toast.LENGTH_SHORT和Toast.LENGTH_LONG","date":"2015-03-16T11:07:26.000Z","path":"2015/03/16/toast-duration-tips/","text":"上一篇博客中介绍了实现双击Back键退出应用的两种实现方式，设定的时间间隔是2000毫秒，我说因为Toast.LENGTH_SHORT就是代表2000毫秒，所以识别为两次连续点击Back的时间间隔就应该设定为2000毫秒。下面介绍我是如何通过查看源码知道Toast.LENGTH_SHORT和Toast.LENGTH_LONG分别代表多少时间的。 当在代码中点击Toast.LENGTH_SHORT的LENGTH_SHORT进入Toast.java的源码时可以看到：12345678910111213/** * Show the view or text notification for a short period of time. This time * could be user-definable. This is the default. * @see #setDuration */public static final int LENGTH_SHORT = 0; /** * Show the view or text notification for a long period of time. This time * could be user-definable. * @see #setDuration */public static final int LENGTH_LONG = 1; Toast.LENGTH_SHORT和Toast.LENGTH_LONG分别是0和1，这显然不是实际的显示时间。再看Toast的makeText()方法：123456789101112131415161718192021222324/** * Make a standard toast that just contains a text view. * * @param context The context to use. Usually your &#123;@link android.app.Application&#125; * or &#123;@link android.app.Activity&#125; object. * @param text The text to show. Can be formatted text. * @param duration How long to display the message. Either &#123;@link #LENGTH_SHORT&#125; or * &#123;@link #LENGTH_LONG&#125; * */public static Toast makeText(Context context, CharSequence text, @Duration int duration) &#123; Toast result = new Toast(context); LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text); result.mNextView = v; result.mDuration = duration; return result;&#125; 在makeText()方法中将传给makeText()的duration赋值给了变量mDuration。再去show()方法中查看：12345678910111213141516171819/** * Show the view for the specified duration. */public void show() &#123; if (mNextView == null) &#123; throw new RuntimeException(\"setView must have been called\"); &#125; INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); TN tn = mTN; tn.mNextView = mNextView; try &#123; service.enqueueToast(pkg, tn, mDuration); &#125; catch (RemoteException e) &#123; // Empty &#125;&#125; mDuration传给了INotificationManager实例service的enqueueToast方法。再追踪enqueueToast就追踪不到了。显然这个INotificationManager是关键，去Android源码中搜搜看吧。androidxref.com是个查看Android源码的好地方，选择KitKat - 4.4.4_r1，搜索INotificationManager，结果中有INotificationManager.aidl，是Android接口定义语言，是为了提供一些机制在不同进程之间进行数据通信。点进去看看，果然有一句：1void enqueueToast(String pkg, ITransientNotification callback, int duration); 继续返回搜索enqueueToast，结果除了INotificationManager、Toast还有一个NotificationManagerService类，点进去查看源码，搜索到实现enqueueToast()方法的位置，继续定位showNextToastLocked()方法-&gt;scheduleTimeoutLocked(ToastRecord r)方法，好了，看到了一句：1long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY; 可以看出，duration等于Toast.LENGTH_LONG时delay取LONG_DELAY，否则取SHORT_DELAY。再看看这两个静态变量的值是多少：12private static final int LONG_DELAY = 3500; // 3.5 secondsprivate static final int SHORT_DELAY = 2000; // 2 seconds 好了，终于找到了。结论就是： Toast.LENGTH_LONG代表的是3500毫秒，其他设定的毫秒值包括Toast.LENGTH_SHORT都是2000毫秒。","tags":[{"name":"Android","slug":"Android","permalink":"http://kodyan.github.io/tags/Android/"}]},{"title":"双击Back键退出应用的实现方法","date":"2015-03-16T06:58:47.000Z","path":"2015/03/16/tap-back-twice-to-exit/","text":"在我们使用app时会注意到，很多应用的退出方式是双击返回键。第一次点击返回键会弹出Toast提示“再按一次返回键退出”，在规定的时间间隔内再次点击返回键就会退出应用。那么这个功能是如何实现的呢？下面给出两种实现方式以及一些有意思的东西。 本文内容 实现方式一 实现方式二 关于Toast的一些思考 实现方式一设置一个flag，用来标识在设定的时间间隔内是否已经点击过一次Back键，默认为false。重写Activity的onBackPressed()方法，捕获Back键的点击操作。如果已经点击过一次Back键，则执行退出操作；否则将flag设置为true，弹出Toast提示“再按一次返回键退出”，并在规定时间间隔之后将flag置为false。这样就实现了在规定的时间间隔内，如果用户点击了两次Back键则执行退出应用操作。下面是参考代码：1234567891011121314151617boolean hasClickBackOnece = false;......public void onBackPressed() &#123; if (hasClickBackOnece) &#123; super.onBackPressed(); finish(); return; &#125; this.hasClickBackOnece = true; ToastUtils.showToast(this, “再按一次返回键退出”, Toast.LENGTH_SHORT); new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; hasClickBackOnece = false; &#125; &#125;, 2000); &#125; 实现方式二设置好识别为连续两次点击的时间间隔，并记录点击Back键时的毫秒时间。若该次点击Back时的毫秒时间 - 已设定的点击毫秒时间 &gt; 时间间隔，则说明两次点击的时间差没有超过设定的时间间隔，此时执行退出操作；否则弹出Toast提示“再按一次返回键退出”，并将该次点击时的毫秒时间赋给记录值。下面是参考代码：12345678910111213141516private static final int TIME_INTERVAL = 2000;private long mBackPressed;@Overridepublic void onBackPressed()&#123; if (System.currentTimeMillis() - mBackPressed &lt;= TIME_INTERVAL) &#123; //add your action here to exit the app super.onBackPressed(); return; &#125; else &#123; Toast.makeText(getBaseContext(), \"Tap back button in order to exit\", Toast.LENGTH_SHORT).show(); &#125; mBackPressed = System.currentTimeMillis();&#125; 关于Toast的一些思考以上两种方法的代码中设置的时间间隔都是2000毫秒，到底应该设置两次点击的时间间隔是多少才会执行退出操作呢？我是这么考虑的： Toast提示“再按一次返回键退出”的duration是多少，则两次点击Back的时间间隔就设定为多少。 识别为两次连续点击的时间间隔与Toast显示“再按一次返回键退出”的持续时间保持一致，这样设置明显是合乎情理的。上面代码中Toast的持续时间是Toast.LENGTH_SHORT，postDelayed中Runnnable时延设置的是2000毫秒。因为Toast.LENGTH_SHORT代表的时间就是2000毫秒。点进源码查看Toast.LENGTH_SHORT明明是0啊，怎么是2000毫秒？下一篇博客我会介绍Toast.LENGTH_SHORT和Toast.LENGTH_LONG分别代表多长时间。 参考资料Android: clicking TWICE the back button to exit activity","tags":[{"name":"Android","slug":"Android","permalink":"http://kodyan.github.io/tags/Android/"}]}]